https://www.aprendejavascript.dev/

##################################################################################################################################################################
En JavaScript hay 9 tipos de datos divididos en 2 grandes grupos:
	-Primitivos: M√°s at√≥micos, m√°s sencillos y puros a la hora de definir los tipos de datos. Como por ejemplo: number, string, boolean, null, undefined, symbol, bigint
	-No primitivos: Objetos, funciones

En JavaScript los n√∫meros enteros y los n√∫meros	con comas SE CONSIDERAN AMBOS COMO N√öMEROS y punto, SON EXACTAMENTE LO MISMO.

2 % 2 devuelve el resto que es 0.

3**3 es elevar 3 a la 3, es decir que el resultado es 27.

En las CADENAS DE TEXTO se usan comillas simples, dobles o de acento: 'Hola mundo'

Se pueden concatenar los strings simplemente con un m√°s. Por ejemplo: "Hola" + "Mundo" = 'HolaMundo'

Se pueden comparar dos valores y nos dar√° de resultado true o false. Como por ejemplo 5 > 3 = true, 5 === 5 = true, 5 !==5 = false.
Tambi√©n se puede usar con strings para ver si son exactamente lo mismo como por ejemplo: 'JavaScript' === 'JavaScript' = true, 'JavaScript' === 'Java' = false, "JavaScript" !== 'PHP' = true
Si lo hacemos con < los compara seg√∫n su valor UNICODE, por lo tanto la letra A es mejor que la letra B, pero las letras may√∫sculas tienen valor menor que las letras min√∫sculas. Por ejemplo 'Alfa' > 'Beta' = false, 'Omega' > 'Beta' = true, 'alfa > 'Alfa' = true.
Si se comparan booleanos simplemente hay que ser que true es mayor que false.

Si comparamos booleanos con el AND(&&), siempre que se compare algo con false va a dar false como por ejemplo: true && true = true, false && true = false, false && false = false
Lo contrario para con el ||, siempre que ponga or con true va a dar true
!true = false
!false = true

EN JAVASCRIPT NO ES NECESARIO ESPECIFICAR EL DATO AL DECLARAR UNA VARIABLE
Para crear una variable usamos la palabra reservada: 'let'
Creamos una variable number: let number = 4
Tambi√©n podemos crear una variable indefinida con pro ejemplo: let texto

Las constantes const son variables que no puedes ser reasignadas, se crean con const. Por ejemplo const PI = 3.14, al intentar cambiarlo as√≠ PI = 3 da error. Y siempre han de ser inicializadas, es decir que siempre que se creen hay que darles un valor -> const RADIO da error. 
Todas las variables son sensibles a las MAY√öSCULAS Y MIN√öSCULAS.

Existen tambi√©n 2 tipos de datos no nombrados antes, null y undefined. Cada uno de estos tipos de datos solo puede ser o null(de null) y undefined(de undefined). Es decir que SIMPRE null = null, undefined = undefined.
Null significa que algo NO tiene VALOR, undefined significa que algo A√öN NO HA SIDO DEFINIDO, por ejemplo cuando creamos una variable sin valor se le pone undefined autom√°ticamente. let rolloDePapel ser√≠a undefined, tambi√©n podemos asignarle manualmente el undefined. Sin embargo, para que una variable tenga el valor NULL hay que asign√°rselo expl√≠citamente. let rolloDePapel = null. NULL SIGNIFICA QUE ALGO VAC√çO.
Ambas cosas son consideradas diferentes, null === undefined -> false. 

##################################################################################################################################################################
El operador type of nos devuelve un string indicando el tipo asignado a una variable, por ejemplo const MAGIC_NUMBER = 7, typeof MAGIC_NUMBER -> "number".
Tambi√©n se puede asignar un valor para comprobarlo directamente como aqu√≠ abajo.
typeof undefined -> undefined
typeof true -> boolean
typeof 42 -> number
typeof "Hola mundo"
Sin embargo, un valor especial, null, el typefor de null devuelve object. Por ejemplo, 
typeof null -> "object"
Por eso si queremos ver si una varible es null ser√≠a as√≠:
let variable = null 
variable === null -> true
Tambi√©n podemos comprobar con typeof dando el resultado. Ser√≠a algo as√≠:
const age = 42
typeof age === 'number' -> true
Podemos encadoenar operadores l√≥gicos para comprobar m√∫ltiples condiciones como por ejemplo:
const age = 42
typeof age === "number" && age > 18 -> true

##################################################################################################################################################################
console.log() es una funci√≥n que sirve para imprimir mensajes en la consola del navegador o del editor de c√≥digo, se usa para depurar el c√≥digo y para imprimir valores de variables y mensajes. Se har√≠a as√≠:
console.log('Hola, JavaScript')
// -> 'Hola, JavaScript'
Tambi√©n se puede averiguar el valor de una variable de esta manera:
const nombre = 'JavaScript'
console.log(nombre)
// -> 'JavaScript'
Tambi√©n podemos concatenar cadenas de texto con una constante, ser√≠a algo as√≠:
const nombre = 'JavaScript'
console.log('Hola, '+ nombre)
// -> 'Hola, JavaScript'
Tambi√©n puedes mostrar varios mensajes y valores en el mismo console.log()
const nombre = 'JavaScript' 
const versi√≥n = 2023
console.log(nombre, version)
// -> 'JavaScript 2023'
Existen otros m√©todos para imprimir mensajes en la consola como por ejemplo:
console.error('Error')
// X Error
console.warn('Advertencia')
// Advertencia
console.info('Informaci√≥n')
// i Informaci√≥n

##################################################################################################################################################################
CONDICIONAL IF:
Un ejemplo de if:
if (conducion) {
	///c√≥digo
	///se ejecuta con la condici√≥n true
}
A continuaci√≥n voy a crear un condicional que compruebe si alguien es mayor de edad:
const edad = 18
if (edad>=18) {
console.log('Registrado Correctamente')
} else {
console.error('No tienes la mayor√≠a de edad')
}
Otro ejemplo con if, elseif y por √∫ltimo el else
if (edad>=18) {
console.log('Es mayor de edad')
}else if(edad>=16) {
console.log('Es casi mayor de edad')
}else {
console.log('NO es mayor de edad')
}
Ejemplo con $$(and):
const edad = 17
const tieneCarnet = true

if (edad >= 18 && tieneCarnet) {
	console.log('Puedes conducir')
} else {
	console.log('No puedes conducir')
}
OTRA T√âCNICA MUY interesante es  guardar el resultado de la condici√≥n EN UNA VARIABLE:
const edad = 17
const tieneCarnet = true
const puedeConducir = edad >= 18 && tieneCarnet

if (puedeconducir) {
	console.log('Puedes conducir')
} else {
	console.log('No puedes conducir')
}
TENER EN CUENTA DE QUE SI EL BLOQUE DE C√ìDIGO SOLO TIENE UNA L√çNEA SE PUEDEN OMITIR LAS LLAVES:
const edad = 17
if (edad >= 18)
  console.log('Eres mayor de edad')
else
  console.log('Eres menor de edad')
TAMBI√âN SE PUEDE ESCRIBIR EN UNA SOLA L√çNEA:
const edad = 18
if (edad >= 18) console.log('Eres mayor de edad')
else console.log('Eres menor de edad')

##################################################################################################################################################################
CONDICIONAL WHILE
let cuentaAtras = 10
while (cuentaAtras > 0) {
cuentaAtras = cuentaAtras - 1
console.log(cuentaAtras + ' segundos')
} 
ATENCION: SI PONES UN WHILE CON UN TRUE COMO CONDICION EL BUCLE SE QUEDA PARA SIEMPRE, EN CAMBIO SI LE PONES FALSE NO SE INICIA NUNCA. Ejemplos:
while (true) {
  console.log('¬°Hola hasta el infinito!')
}
while (false) {
  console.log('Nunca entro aqu√≠!')
}

Para controlar cuando queremos salir de un bucle podemos utilizar la palabra BREAK.
let cuentaAtras = 10

while (cuentaAtras > 0) {
  console.log(cuentaAtras)
  cuentaAtras = cuentaAtras - 1

  // si la cuenta atr√°s es 5, salimos del bucle
  if (cuentaAtras === 5) {
    break // <---- salimos del bucle
  }
}

Tambi√©n podemos saltar una iteraci√≥n con continue. Con continue el bucle salta a la siguiente iteraci√≥n. El c√≥digo de bajo es para que se salte el paso de imprimir los pares.
let cuentaAtras = 10

while (cuentaAtras > 0) {
  cuentaAtras = cuentaAtras - 1

  // si la cuenta atr√°s es un n√∫mero par...
  if (cuentaAtras % 2 === 0) {
    continue // <---- saltamos a la siguiente iteraci√≥n
  }

  console.log(cuentaAtras)
}

MUY IMPORTANTE: LAS VARIABLES CREADAS dentro de un bucle solo existen dentro de ese bucle. es decir que cuando ese bucle termina esa variable desaparece.

##################################################################################################################################################################
CONDICIONAL DO WHILE
El do while a diferencia del while se ejecuta al menos una vez:
do {
  // c√≥digo que se ejecuta al menos una vez
} while (condici√≥n);

confirm se usa para que te salte una notificaci√≥n en la que puedes elegir una opci√≥n u otra. Si elige aceptar la funci√≥n devuelve true, si elige cancelar la funci√≥n devuelve false. Por ejemplo: 
confirm("¬øTe gusta JavaScript?");

PODEMOS GUARDAR LA RESPUESTA DEL CONFIRM EN UNA VARIABLE de esta manera:
let respuesta = confirm("¬øTe gusta JavaScript?")
console.log(respuesta) // -> true o false

##################################################################################################################################################################
DECLARACIONES
Son sentencias que definen la creaci√≥n de una variable, funci√≥n o clase. Son por as√≠ decirlo las instrucciones que le damos a JavaScript para que haga algo. Por ejemplo una declaraci√≥n de variable es una sentencia que le da un nombre y un valor a una variable:
let nombre = "Juan"

EXPRESIONES
Las expresiones son sentencias que producen un valor, pueden ser tan simples como un solo n√∫mero o una cadena de texto o tan complejas como el c√°lculo de una operaci√≥n matem√°tica. Por ejemplo:
2 + 3 // -> 5

##################################################################################################################################################################
BUCLES CON FOR:
for (let number = 1; number <= 10; number++) {
  console.log(number)
}

for (let i = 0, j = 5; i < 5; i++, j--) {
  console.log(i, j);
}

for (let i = 0; i < 10; i++) {
  const esPar = i % 2 === 0
  if (esPar) {
    continue
  }

  // Solo mostramos este consola.log si es impar
  console.log(i)

  // Salimos del bucle al llegar al 7
  if (i === 7) {
    break
  }
}

ATENTO AQU√ç ABAJO: SI i LLEGA A SER 3 SE SALE DEL BUCLE COMPLETAMENTE

for (let i = 0; i < 10 && i !== 3; i++) {
  console.log('Hola')
}

##################################################################################################################################################################
SWITCH

Switch es una estructura de control. Permite ejecutar diferentes bloques de c√≥digo dependiendo del valor de una expresi√≥n. Suele ir asignado de un brake(que es para salir del bucle) y un default(que es b√°sicamente un else) Por ejemplo:
const dia = "lunes"

switch (dia) {
  case "lunes":
    console.log("¬°Hoy es lunes! üò¢")
    break

  default:
    console.log("No es lunes, YAY! üöÄ")
    break
}

Podemos usar Date().getDay() para obtener un valor del d√≠a de hoy. Por ejemplo:
const dia = new Date().getDay()

// segun el dia de la semana, mostramos un mensaje diferente
switch (dia) {
  case 0:
    console.log("¬°Hoy es domingo! üò¥")
    break
  case 1:
    console.log("¬°Nooo, es lunes! üò¢")
    break
  case 2:
    console.log("¬°Hoy es martes! ü•µ")
    break
  case 3:
    console.log("¬°Hoy es mi√©rcoles! ü§ì")
    break
  default:
    console.log("Se acerca el fin de! üöÄ")
    break
}

##################################################################################################################################################################
FUNCIONES

Las funciones en javascript se pueden definir de varias maneras pero la forma m√°s com√∫n y b√°sicaes mediante la palabra clave function. Por ejemplo:

function saludar() {
   console.log('Hola Miguel')
}

Para llamar a la funci√≥n simplemente escribimos su nombre seguido de par√©ntesis: 

saludar()

Las funcionen pueden devolver un resultado: 

function sumar() {
  return 1 + 1
}

const resultado = sumar()	///se puede guardar el resultado dentro de una variableg

console.log(sumar())

Una funci√≥n con randomg interesante:
function getRandomNumber() {
  // recuperamos un n√∫mero aleatorio entre 0 y 1
  const random = Math.random() // por ejemplo: 0.6803487380457318

  // lo multiplicamos por 10 para que est√© entre 0 y 10
  const multiplied = random * 10 // -> 6.803487380457318

  // redondeamos hacia abajo para que est√© entre 0 y 9
  const rounded = Math.floor(multiplied) // -> 6

  // le sumamos uno para que est√© entre 1 y 10
  const result = rounded + 1 // -> 7

  // devolvemos el resultado
  return result
}

##################################################################################################################################################################
PAR√ÅMETROS
Las funciones pueden recibir par√°metros para que su comportamiento pueda cambiar seg√∫n los datos que le proporcionemos. Por ejemplo:

function saludar(nombre) {
  console.log("Hola " + nombre)
}
saludar('Miguel') // -> Hola Miguel
saludar('Itziar') // -> Hola Itziar
saludar('Carmen') // -> Hola Carmen

function sumar(a, b) {
  return a + b
}
const resultadoSuma = sumar(2, 3)
console.log(resultadoSuma) // -> 5

Con return dentro de un condicional, si se da la condici√≥n sale de la funci√≥n directamente y devuelve el valor que le asignemos. Esto se hace de esta manera:

function cocinarMicroondas(plato, tiempo, potencia) {
  if (plato === 'üê•' && tiempo === 1 && potencia === 5) {
    return 'üçó'
  }

  if (plato === 'ü•ö' && tiempo === 2 && potencia === 3) {
    return 'üç≥'
  }

  return '‚ùå Plato no soportado'
}

##################################################################################################################################################################
Function Expression
Es una funci√≥n que SE LE ASIGNA A UNA VARIABLE. Por ejemplo:
// esto es una function expression
const sum = function (a, b) {
  return a + b
}

// esto es una declaraci√≥n de funci√≥n
function sum(a, b) {
  return a + b
}

Con esa function expresi√≥n, a la funci√≥n se le asigna la variable sum. Esto significa que podemos llamar a la funci√≥n usando el nombre de la varible:

sum(1, 2) // 3

Es muy similar a una funci√≥n declarada simplemente con function, pero, hay una diferencia muy importante: el hoisting
El hoisting es un t√©rmino para describir c√≥mo JavaScript PARECE que mueve las declaraciones de FUNCIONES al principio del c√≥digo de forma que las puedas usar incluso antes de declararlas. Por ejemplo:

sum(1, 2) // 3

function sum(a, b) {
  return a + b
}

Esto de arriba deber√≠a dar error pero no, JavaScript asigna en memoria durante la fase de compilaci√≥n las declaraciones de funciones y por eso al ejecutarse el c√≥digo tiene acceso a esa posici√≥n de memoria a la que se refiere la funci√≥n. De forma simple ser√≠a como si JavaScript moviese las declaraciones de LAS FUNCIONES al principio del c√≥digo.
PEEEEEEEEEEERO, EN LAS FUNCTION EXPRESSION NO SE APLICA EL HOISTING. Esto quiere decir que si no declaras la FUNCTION EXPRESSION antes de llamarla VA A DAR UN ERROR. As√≠:
sum(1, 2) // ‚ùå ReferenceError: sum is not defined

const sum = function (a, b) {
  return a + b
}

##################################################################################################################################################################
Arrow FUNCTION
B√°sicamente son una forma conscisa de crear funciones en JavaScript, y se han hecho muy populares desde hace unos a√±os por su sintaxis simplificada. Su sintaxis es as√≠:

const miFuncionFlecha = () => {
  // c√≥digo a ejecutar
}

En lugar de la palabra function, utilizamos una flecha => para definir la funci√≥n. Tambi√©n podemos omitir los par√©ntesis alrededor de los par√°metros si solo tenemos UN PARAMETRO.
const saludar = nombre => {
  console.log("Hola " + nombre)
}

Cuando una funci√≥n flecha tiene una sola expresi√≥n, podemos omitir las llaves {} y la palabra clave return para hacerla a√∫n m√°s corta. Esto se conoce como return impl√≠cito. Se puede hacer de esta manera:
// Declaraci√≥n de funci√≥n regular
function sumar(a, b) {
  return a + b
}

// Funci√≥n flecha
const sumarFlecha = (a, b) => {
  return a + b
}

// Funci√≥n flecha con return impl√≠cito
const sumarFlecha = (a, b) => a + b

IMPORTANTE, EL RETURN IMPL√çCITO SOLO SE PUEDE APLICAR SI NO USAS LAS LLAVES:
const sum = (a, b) => { a + b }
sum(2, 3)

ESTO DE ARRIBA DAR√çA ERROR

##################################################################################################################################################################
Recursividad

La recursividad es una t√©cnica de programaci√≥n que consiste en que una funci√≥n se llame as√≠ misma, para que no se quede infinita hay que crear una condici√≥n base. Esto se hace as√≠:
function cuentaAtras(numero) {
  // Condici√≥n base: Si el n√∫mero que recibe es
  // menor de 0 entonces salimos de la funci√≥n
  if (numero < 0) { return }

  // Si el n√∫mero era mayor o igual a 0, lo mostramos
  console.log(numero)

  // Y llamamos a la funci√≥n con el n√∫mero anterior
  cuentaAtras(numero - 1)
}

Esto que hemos hecho arriba es una especie de bucle usando la funci√≥n. As√≠ es como funciona la recursividad. Si llamamos a la funci√≥n con el n√∫mero 3, el resultado ser√°:
cuentaAtras(3)
// -> 3
// -> 2
// -> 1
// -> 0

La recursividad se usa muchas veces para solucionar algoritmos. Por ejemplo, vamos a crear una funci√≥n que calcule el factorial de un n√∫mero. Ser√≠a as√≠:

function factorial(n) {
  // Condici√≥n base: Si el n√∫mero es 0 o 1, devolvemos 1
  // y no llamamos a la funci√≥n de nuevo
  if (n === 0 || n === 1) {
    return 1
  } else {
    // Si el n√∫mero es mayor que 1, llamamos a la funci√≥n
    return n * factorial(n - 1)
  }
}

console.log(factorial(5)) // Resultado: 120
console.log(factorial(3)) // Resultado: 6

##################################################################################################################################################################
Arrays: colecciones de elementos

Los arrays son colecciones de datos. Para declarar un array se usan los corchetes [] y dentro los elementos se separan por comas. Por ejemplo:
[1, 2, 3, 4, 5]

Los elementos de un array pueden ser de cualquier tipo, incluso otros arrays:
[1, 2, 3, 4, [5, 6, 7, 8, 9]]

y aunque NO ES RECOMENDABLE se pueden mezclar tipos de datos dentro:
['uno', 2, true, null, undefined]

Para asignar un array a una variable, lo hacemos igual que con los otros tipos de datos:
const numbers = [1, 2, 3, 4, 5]
let names = ['Dani', 'Miguel', 'Maria']

Si intentamos acceder a un elemento que no existe, nos devolver√° undefined.
const numbers = [1, 2, 3, 4, 5]
console.log(numbers[10]) // undefined

OJO,IMPORTANTE, lo normal es que no deje cambiar las variables const, PEEEEEERO, lo que s√≠ se puede cambiar es lo de dentro de dentro de CONST. Un array dentro de const S√ç QUE SE PUEDE CAMBIAR.

##################################################################################################################################################################
M√©todos y propiedades de Array
Los arrays en JavaScript tienen una serie de m√©todos y propiedades que nos permiten trabajar con ellos de forma sencilla.

Para conocer la longitud de un array usamos .length Por ejemplo:
const frutas = ["manzana", "pera", "pl√°tano", "fresa"]
console.log(frutas.length) // 4

Tambi√©n podemos CORTAR su longitud asignando un nuevo valor de esta manera:
const frutas = ["manzana", "pera", "pl√°tano", "fresa"]
frutas.length = 2

console.log(frutas) // ["manzana", "pera"]
console.log(frutas.length) // 2

El m√©todo .push() sirve para a√±adir un elemento al final de un array y tambi√©n nos devuelve la nueva longitud del array. Por ejemplo:
const frutas = ["pl√°tano", "fresa"]
frutas.push("naranja")
console.log(frutas) // ["pl√°tano", "fresa", "naranja"]

El m√©todo .pop() elimina y devuelve el √∫ltimo elemento de un array:
const frutas = ["pl√°tano", "fresa", "naranja"]
const ultimaFruta = frutas.pop()
console.log(frutas) // ["pl√°tano", "fresa"]
console.log(ultimaFruta) // "naranja"

El m√©todo shift elimina y devuelve el primer elemento de un array. Es lo mismo que .pop() pero con el primer elemento en lugar del √∫ltimo.
const frutas = ["pl√°tano", "fresa", "naranja"]
const primeraFruta = frutas.shift()
console.log(frutas) // ["fresa", "naranja"]
console.log(primeraFruta) // "pl√°tano"

El m√©todo .unshift() a√±ade un elemento al principio de un array. Es lo mismo que .push() pero con el primer elemento en lugar del √∫ltimo.
const frutas = ["pl√°tano", "fresa", "naranja"]
frutas.unshift("manzana")
console.log(frutas) // ["manzana", "pl√°tano", "fresa", "naranja"]

Podemos concatenar(juntar) dos arrays usando el m√©todo concat().
const numbers = [1, 2, 3]
const numbers2 = [4, 5]
const allNumbers = numbers.concat(numbers2)
console.log(allNumbers) // [1, 2, 3, 4, 5]

Otra forma de concatenar es usando el operador ‚Ä¶ (spread operator) de esta manera:
const numbers = [1, 2, 3]
const numbers2 = [4, 5]
//                    1, 2, 3        4, 5                     
const allNumbers = [...numbers, ...numbers2]
console.log(allNumbers) // [1, 2, 3, 4, 5]

##################################################################################################################################################################
Iteraci√≥n de Arrays en JavaScript

Con el while se hace de esta manera:
let frutas = ['üçé', 'üçå', 'üçì']
let i = 0 // lo usaremos como √≠ndice
while (i < frutas.length) {
  console.log(frutas[i]) // imprime el elemento en la posici√≥n i
  i++ // incrementamos el √≠ndice en 1 para la siguiente iteraci√≥n
}

Con el for se hace de esta manera:
let frutas = ['üçé', 'üçå', 'üçì']
for (let i = 0; i < frutas.length; i++) {
  console.log(frutas[i]) // imprime el elemento en la posici√≥n i
}

Aparte del while y del for existe una estructura de control que nos permite iterar sobre los elementos de un array: for...of. Es m√°s simple que for ya que no se necesita crear una variable para guardar el √≠ndice del elemento que estamos iterando. Se hace as√≠:
let frutas = ['üçé', 'üçå', 'üçì']
for (let fruta of frutas) {
  console.log(fruta) // imprime el elemento en la posici√≥n i
}

Ahora un m√©todo importante, array.forEach(), que nos permite ejecutar dentro una function para cada uno de los elementos del array. Esta funci√≥n recibe como par√°metros el elemento que se est√° iterando en ese momento, el √≠ndice del elemento y el propio array. As√≠:
let frutas = ['üçé', 'üçå', 'üçì']
frutas.forEach(function (fruta, index, originalArray) {
  console.log(fruta) // imprime el elemento en la posici√≥n i
})

Usando arrow function e indicando solo los par√°metros que necesitamos se podr√≠a simplificar a√∫n m√°s:
let frutas = ['üçé', 'üçå', 'üçì']
frutas.forEach((fruta) => {
  console.log(fruta) // imprime el elemento en la posici√≥n i
})

##################################################################################################################################################################
B√∫squeda en Arrays con sus m√©todos

Existen varios m√©todos en JavaScript que te permiten, buscar dentro de un Array algo espec√≠fico. Estos m√©todos incluyes indexOf, some, every, find, findIndex e includes.
Cada uno de estos m√©todos tiene un prop√≥sito espec√≠fico y una funcionalidad √∫nica. Vamos a explorar cada uno de ellos utilizando un Array de emojis como ejemplo.
const emojis = ['‚ú®', 'ü•ë', 'üòç']

El m√©todo indexOf te permite encontrar la posici√≥n de un elemento dentro de un Array. Si el elemento no existe, entonces retorna -1.
const emojis = ['‚ú®', 'ü•ë', 'üòç']
const posicionCorazon = emojis.indexOf('üòç')
console.log(posicionCorazon) // -> 2

El m√©todo includes determina si un Array incluye un determinado elemento, devolviendo true o false seg√∫n corresponda.
const emojis = ['‚ú®', 'ü•ë', 'üòç']
const tieneCorazon = emojis.includes('üòç')
console.log(tieneCorazon) // -> true

El m√©todo some te permite verificar si al menos uno de los elementos de un Array cumple con una condici√≥n.
Para utilizarlo le pasas una funci√≥n como argumento. Esta funci√≥n recibe como argumento cada uno de los elementos Array y debe retornar un valor booleano.
Si al menos uno de los elementos retorna true, entonces el m√©todo some retorna true, si no, false.
const emojis = ['‚ú®', 'ü•ë', 'üòç']
const tieneCorazon = emojis.some(emoji => emoji === 'üòç')
console.log(tieneCorazon) // -> true

Lo de arriba ya se pod√≠a hacer con includes pero some es mucho m√°s potente. Podemos crear funciones m√°s complejas para pasarle al m√©todo some. Por ejemplo, podemos crear una funci√≥n que verifique si un Array contiene un elemento que sea un string de m√°s de 3 caracteres.
const names = ['Leo', 'Isa', '√çan', 'Lea']
const tieneNombreLargo = names.some(name => name.length > 3)
console.log(tieneNombreLargo) // -> false

El m√©todo every te permite verificar si todos los elementos de un Array cumplen una condici√≥n. Es como som,e pero en lugar de verificar si al menos uno de los elementos cumple la condici√≥n los verifica todos.
Para utilizarlo, le pasas una funci√≥n como argumento. Esta funci√≥n recibe como argumento el elemento del array que est√° iterando en ese momento y debe retornar un valor BOOLEANO para saber si el elemento ha cumplido con la condici√≥n.
Si todos los elementos retornan true, entonces el m√©todo every retorna true. Si al menos uno de los elementos retorna false, entonces el m√©todo every retorna false.
// ¬øTodos los emojis son felices?
const emojis = ['üòÄ', 'üòÇ', 'üòç', 'üò≠', 'ü•∫', 'üòé']
const todosSonFelices = emojis.every(emoji => emoji === 'üòÄ')
console.log(todosSonFelices) // -> false

// ¬øTodos los n√∫meros son pares?
const numbers = [2, 4, 7, 10, 12]
const todosSonPares = numbers.every(number => number % 2 === 0)
console.log(todosSonPares) // -> false

// ¬øTodos los strings son mayores a 3 caracteres?
const names = ['Miguel', 'Juan', 'Itziar', 'Isabel']
const todosLosNombresSonLargos = names.every(name => name.length > 3)
console.log(todosLosNombresSonLargos) // -> true

El m√©todo find te permite encontrar el primer elemento que cumple una condici√≥n. Lo interesante es que este m√©todo te devuelve el elemento en s√≠, NO UN VALOR BOOLEANO como some o every. Hay que pasarle una funci√≥n como argumento que retorne un valor booleano a√∫n as√≠.
const numbers = [13, 27, 44, -10, 81]
// encuentra el primer n√∫mero negativo
const firstNegativeNumber = numbers.find(number => number < 0)
console.log(firstNegativeNumber) // -> -10
Arriba: Si no encuentra ning√∫n elemento que cumpla con la condici√≥n, el m√©todo find retorna undefined.

El m√©todo findIndex es similar a find pero este devuelve el √≠ndice del elemento.
const numbers = [13, 27, 44, -10, 81]
// encuentra el √≠ndice del primer n√∫mero negativo
const firstNegativeNumberIndex = numbers.findIndex(number => number < 0)
console.log(firstNegativeNumberIndex) // -> 3
// ahora puedes usar el √≠ndice para acceder al elemento
console.log(numbers[firstNegativeNumberIndex]) // -> -10

##################################################################################################################################################################
Ordenamiento de Arrays en JavaScript

JavaScript proporciona un m√©todo llamado .sort() para ordenar sus elementos. Por defecto no es muy √∫til pero se puede personalizar su comportamiento para que ordene los elementos de manera que necesites.

Por defecto .sort() hace una ordenaci√≥n un poco extra√±a. Ordena los n√∫meros en funci√≥n de su valor como cadena de texto, no en el valor n√∫merico:
let numeros = [5, 10, 2, 25, 7]
numeros.sort()
console.log(numeros) // [10, 2, 25, 5, 7]

Para personalizar c√≥mo sort ordena los elementos, puedes pasar una funci√≥n de comparaci√≥n como argumento. La funci√≥n de comparaci√≥n debe devolver:
-Un VALOR NEGATIVO si el primer argumento debe aparecer antes que el segundo.
-Un VALOR POSITIVO si el segundo argumento debe aparecer antes que el primero.
-Cero si ambos argumentos son iguales
Por ejemplo para ordenar los n√∫meros de menor a mayor se puede usar la siguiente funci√≥n de comparaci√≥n:
let numeros = [5, 10, 2, 25, 7]
numeros.sort(function(a, b) {
  return a - b
})
console.log(numeros) // [2, 5, 7, 10, 25]

Para ordenarlos de manera descendente, de mayor a menor, deber√≠as cambiar el orden del return:
let numeros = [5, 10, 2, 25, 7]
numeros.sort(function(a, b) {
  return b - a
})
console.log(numeros) // [25, 10, 7, 5, 2]

Tambi√©n podemos usar una arrow function para simplificar el c√≥digo:
let numeros = [5, 10, 2, 25, 7]
numeros.sort((a, b) => a - b)

Como ves, .sort() modifica el array original. Si quieres obtener un array ordenado sin modificar el original, puedes usar el m√©todo .toSorted():
let numeros = [5, 10, 2, 25, 7]
let numerosOrdenados = numeros.toSorted((a, b) => {
  return a - b
})
console.log(numerosOrdenados) // [2, 5, 7, 10, 25]
console.log(numeros) // [5, 10, 2, 25, 7]

##################################################################################################################################################################
Transformaci√≥n de Arrays en JavaScript

El m√©todo filter crea un nuevo array con todos los elementos que devuelven TRUE al ejecutar una funci√≥n que le pasamos como par√°metro. Por ejemplo, podr√≠amos filtrar en un nuevo array todos los n√∫meros pares de un array de n√∫meros:
const numbers = [1, 2, 3, 4, 5, 6, 7]
const evenNumbers = numbers.filter(function (number) {
  return number % 2 === 0
})
console.log(evenNumbers) // [2, 4, 6]

O tambi√©n quedarnos con todas las cadenas de texto que tengan la letra a:
const strings = ['hola', 'adi√≥s', 'casa', 'coche', 'perro', 'gato']
// en las cadenas de texto podemos usar el m√©todo `includes`
// para saber si una cadena contiene otra:
const stringsWithA = strings.filter(string => string.includes('a'))
console.log(stringsWithA) // ['hola', 'adi√≥s', 'casa', 'gato']

El m√©todo map crea un nuevo array de la misma longitud que el original, pero con los elementos transformados por una funci√≥n que le pasamos como par√°metro. As√≠ que la funci√≥n recibir√° cada elemento del array y tendremos que devolver el elemento transformado. Por ejemplo, podr√≠amos crear un array con el doble de cada n√∫mero de un array de n√∫meros:
const numbers = [1, 2, 3]
const doubleNumbers = numbers.map((number) => {
  return number * 2
})
console.log(doubleNumbers) // [2, 4, 6]

O tambi√©n se podr√≠a crear un array con la longitud de cada cadena de texto de un array de cadenas:
const strings = ['hola', 'javascript', 'midu', 'programaci√≥n']
const stringsLength = strings.map((string) => string.length)
console.log(stringsLength) // [4, 10, 4, 12]

map + filter. En JavaScript podemos crear un encadenamiento de m√©todos. De esta forma, si un m√©todo devuelve un array, podemos llamar a otro m√©todo sobre ese array sin necesidad de guardarlo en una variable. Imagina que queremos crear un array con el doble de los n√∫meros y s√≥lo quedarnos con los que sean mayores que 5:
const numbers = [1, 2, 3, 4, 5, 6, 7]
const numsGreaterThanFive = numbers
  .map(number => number * 2) // [2, 4, 6, 8, 10, 12, 14]
  .filter(number => number > 5) // [6, 8, 10, 12, 14]
console.log(numsGreaterThanFive) // [6, 8, 10, 12, 14]

Esto tambi√©n se podr√≠a hacer al rev√©s:
const numbers = [1, 2, 3, 4, 5, 6, 7]
const doubleEvenNumbers = numbers
  .filter(number => number % 2 === 0) // [2, 4, 6]
  .map(number => number * 2) // [4, 8, 12]
console.log(doubleEvenNumbers) // [4, 8, 12]

El m√©todo reduce es un poco m√°s complejo. Este m√©todo permite crear un √∫nico valor a partir de un Array. 
Recibe dos par√°metros: una funci√≥n que se ejecutar√° por cada elemento y un valor inicial, opcional, que ser√° donde podemos acumular los valores.
El primer par√°metro de reduce, que es la funci√≥n que se ejecutar√° por cada elemento, recibe tres par√°metros:
	-El acumulador: el valor que se va a ir acumulando en cada iteraci√≥n
	-El elemento actual: el elemento del Array que estamos iterando en ese momento.
	-El √≠ndice: la posici√≥n del elemento actual en el Array
Y debe devolver el valor que se va a acumular en cada iteraci√≥n.
Un caso de uso muy t√≠pico de reduce es sumar todos los elementos de un Array:
const numbers = [1, 2, 3]
const sum = numbers.reduce((accumulator, currentNumber) => {
  return accumulator + currentNumber
}, 0) // <- el 0 es el valor inicial
console.log(sum) // 6

Podr√≠amos usar map y filter junto a un reduce para evitar un array intermedio. Por ejemplo, imagina que queremos doblar los n√∫meros pares y solo quedarnos con los mayores de 5:
const numbers = [1, 2, 3, 4, 5, 6, 7]
const doubleEvenNumbers = numbers.reduce((accumulator, currentNumber) => {
  const isEven = currentNumber % 2 === 0
  const doubled = currentNumber * 2
  const isGreaterThanFive = doubled > 5
  // si es par y mayor que 5, lo a√±adimos al array
  if (isEven && isGreaterThanFive) {
    // para ello devolvemos un nuevo array con el valor actual
    return accumulator.concat(doubled)
  } else {
    // si no, devolvemos lo que ya ten√≠amos
    return accumulator
  }
}, []) // <- el array vac√≠o es el valor inicial
console.log(doubleEvenNumbers) // [8, 12]

##################################################################################################################################################################
Matrices
En matem√°ticas y en programaci√≥n, una matriz se refiere a una colecci√≥n de elementos dispuestos en filas y columnas. En t√©rminos m√°s sencillos y en JavaScript, podemos representar una matriz como un array de arrays.

Para empezar, aqu√≠ se muestra c√≥mo se puede crear una matriz simple de 2x3 en JavaScript:
const matriz = [
  [1, 2, 3],
  [4, 5, 6]
]

Para acceder a los elementos de una matriz, necesitaremos utilizar dos √≠ndices: uno para la fila y otro para la columna.
Por ejemplo si queremos acceder al n√∫mero 6 en la matriz anterior lo har√≠amos de la siguiente manera:
let numero = matriz[1][2]
console.log(numero) // -> 6
Aqu√≠, el primer √≠ndice, [1], se refiere a la segunda fila (recuerda que los arrays en JavaScript tienen un √≠ndice base cero), y el segundo √≠ndice, [2], se refiere a la tercera columna.

Podemos utilizar bucles anidados para iterar sobre todos los elementos de una matriz. Aqu√≠ hay un ejemplo de c√≥mo hacerlo utilizando un bucle for:
for (let i = 0; i < matriz.length; i++) { // {1}
  for (let j = 0; j < matriz[i].length; j++) { // {2}
    console.log(matriz[i][j])
  }
}



